import numpy as np
#numpy数组中整型数默认为int32
# b = np.array([1, 2, 3],dtype=int)
# print(b.dtype)
# c = b.astype(float)
# print(c.dtype)
'''
1.内置类型
a)优点:
可指定数据类型所占内存是多少
可灵活变化
b)缺点
因为具有灵活性，所以牺牲性能（需要留出足够空间）
无法使用固定内存地址计算方法，只能动态完成，因为有关地址的运算就会占用运行时间。
注：在numpy里为每一种类型都提供了固定大小，所以有关地址运算完全可以通过类型来确定。
numpy自己定义了一套独立的数据类型体系。数据类型有固定长度，字节数都是固定的。

numpy.bool_  : 一个布尔类型占一个字节

有符号版本(正负数):
int8    1字节 有符号类型
int16   2字节 有符号类型
int32   4字节 有符号类型
无符号版本(只有正数)
uint8   1字节 无符号类型 
uint16   2字节 无符号类型
uint32   4字节 无符号类型
浮点类型:
float16    2字节 浮点型 有符号
float32    4字节 浮点型 有符号
float64    8字节 浮点型 有符号
复数：(实部和虚部分别用2个4字节浮点型表示):
comlex64  8字节复数型     #实部占4字节，虚部占4字节
complex128 16字节复数型 
注：1复数 = 2个浮点类型的组合
str_:字符串型 （没有规定多少字节，因为字符串类型却决于与字符串Unicode的长度，
字符串长度根据字串包含的字符决定）
注：1 Unicode = 4个字节
可用dtype和astype来设置类型转换
'''

#2.numpy自定义类型:
#2.1 直接使用内置类型的原始名
#2.2 使用紧凑型格式(类型编码字符串)

'''
numpy.int16   => i2
numpy.uint32  => U4
numpy.float64 =>  F8
numpy.comlex128 => C16
'''
#2.3 多字节的整数存在大小端序
#多字节整数可以加上字节序作前缀
'''
"<"小端序  低数位 低地址 

"=" 系统默认，不能人为指定

">"大端序  低数位 高地址 

'''

#大端序字节数：低数位，高地址

# a = np.array([0x1234],dtype=(
#     '>u2',{'low':('u1',0),'high':('u1',1)}))
#
#
# print('{:x}'.format(a[0])) #以16进制输出a里面的0号元素
# print('{:x},{:x}'.format(a['low'][0],a['high'][0]))

#"<"小端序  低数位 低地址
# a = np.array([0x1234],dtype=(
#     '<u2',{'lo':('u1',0),'hi':('u1',1)}))
#
# print('{:x},{:x}'.format(a['lo'][0],a['hi'][0]))

# a = np.array([0x1234],dtype=(
#     '=u2',{'lo':('u1',0),'hi':('u1',1)}))
#
# print('{:x},{:x}'.format(a['lo'][0],a['hi'][0]))



